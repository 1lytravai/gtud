# -*- coding: utf-8 -*-
"""Lab9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-JxcilUkPGRKfZHrpn5I_Nplnc-NUSSO
"""

import sympy as sp
import numpy as np
import math

x = sp.symbols('x')

#Excercise 1
x = sp.symbols('x')

f_a = 3*x**4 - 16*x**3 + 18*x**2 - 9
f_b = (x + 2)/(2*x**2)
f_c = -x**(2/3) + x**2 + 3*x + 4
f_d = (5*x**2 + 5)/x

f_prime_a = sp.diff(f_a, x)
f_prime_b = sp.diff(f_b, x)
f_prime_c = sp.diff(f_c, x)
f_prime_d = sp.diff(f_d, x)

critical_numbers_a = sp.solve(f_prime_a, x)
critical_numbers_b = sp.solve(f_prime_b, x)
critical_numbers_c = sp.solve(f_prime_c, x)
critical_numbers_d = sp.solve(f_prime_d, x)

print("Nghiệm của fa'(x) = 0 là:", critical_numbers_a)
print("Nghiệm của fb'(x) = 0 là:", critical_numbers_b)
print("Nghiệm của fc'(x) = 0 là:", critical_numbers_c)
print("Nghiệm của fd'(x) = 0 là:", critical_numbers_d)



import sympy as sp

x = sp.symbols('x')

f_2a = 3*x**4 - 16*x**3 + 18*x**2 - 9
f_aprime = sp.diff(f_2a, x)
critical_a = sp.solve(f_aprime, x)
f_a_double_prime = sp.diff(f_aprime, x)

print("Câu a:")
for cn in critical_a:
    val = f_a_double_prime.subs(x, cn)
    nature = "Local minimum" if val > 0 else "Local maximum" if val < 0 else "Test inconclusive"
    print(f"At x = {cn}: f''(x) = {val} → {nature}")
print()

f_2b = (x + 2)/(2 * x**2)
f_bprime = sp.diff(f_2b, x)
critical_b = sp.solve(f_bprime, x)
f_b_double_prime = sp.diff(f_bprime, x)

print("Câu b:")
for cn in critical_b:
    if cn.is_real:
        val = f_b_double_prime.subs(x, cn)
        nature = "Local minimum" if val > 0 else "Local maximum" if val < 0 else "Test inconclusive"
        print(f"At x = {cn}: f''(x) = {val} → {nature}")
print()

f_2c = (-x**2)/3 + x**2 + 3*x + 4
f_cprime = sp.diff(f_2c, x)
critical_c = sp.solve(f_cprime, x)
f_c_double_prime = sp.diff(f_cprime, x)

print("Câu c:")
for cn in critical_c:
    val = f_c_double_prime.subs(x, cn)
    nature = "Local minimum" if val > 0 else "Local maximum" if val < 0 else "Test inconclusive"
    print(f"At x = {cn}: f''(x) = {val} → {nature}")
print()

f_2d = (5*x**2 + 5)/x
f_dprime = sp.diff(f_2d, x)
critical_d = sp.solve(f_dprime, x)
f_d_double_prime = sp.diff(f_dprime, x)

print("Câu d:")
for cn in critical_d:
    if cn.is_real:
        val = f_d_double_prime.subs(x, cn)
        nature = "Local minimum" if val > 0 else "Local maximum" if val < 0 else "Test inconclusive"
        print(f"At x = {cn}: f''(x) = {val} → {nature}")

import sympy as sp

#Exercise 3

x = sp.symbols('x')

# Câu a
f3a = x**3 - 27*x
a1, a2 = 0, 5
df3a = sp.diff(f3a, x)
cvals_3a = [val.evalf() for val in sp.solve(df3a, x) if a1 <= val <= a2]
cvals_3a.extend([a1, a2])
yvals_3a = [f3a.subs(x, val) for val in cvals_3a]
print("Câu a:")
for xi, yi in zip(cvals_3a, yvals_3a):
    print(f"x = {xi}, f(x) = {yi}")
print(f"Giá trị lớn nhất: {max(yvals_3a)}, nhỏ nhất: {min(yvals_3a)}\n")

# Câu b
f3b = (3/2)*x**4 - 4*x**3 + 4
b1, b2 = 0, 3
df3b = sp.diff(f3b, x)
cvals_3b = [val.evalf() for val in sp.solve(df3b, x) if b1 <= val <= b2]
cvals_3b.extend([b1, b2])
yvals_3b = [f3b.subs(x, val) for val in cvals_3b]
print("Câu b:")
for xi, yi in zip(cvals_3b, yvals_3b):
    print(f"x = {xi}, f(x) = {yi}")
print(f"Giá trị lớn nhất: {max(yvals_3b)}, nhỏ nhất: {min(yvals_3b)}\n")

# Câu c
f3c = (1/2)*x**4 - 4*x**2 + 5
c1, c2 = 1, 3
df3c = sp.diff(f3c, x)
cvals_3c = [val.evalf() for val in sp.solve(df3c, x) if c1 <= val <= c2]
cvals_3c.extend([c1, c2])
yvals_3c = [f3c.subs(x, val) for val in cvals_3c]
print("Câu c:")
for xi, yi in zip(cvals_3c, yvals_3c):
    print(f"x = {xi}, f(x) = {yi}")
print(f"Giá trị lớn nhất: {max(yvals_3c)}, nhỏ nhất: {min(yvals_3c)}\n")

# Câu d
f3d = (5/2)*x**4 - (20/3)*x**3 + 6
d1, d2 = -1, 3
df3d = sp.diff(f3d, x)
cvals_3d = [val.evalf() for val in sp.solve(df3d, x) if d1 <= val <= d2]
cvals_3d.extend([d1, d2])
yvals_3d = [f3d.subs(x, val) for val in cvals_3d]
print("Câu d:")
for xi, yi in zip(cvals_3d, yvals_3d):
    print(f"x = {xi}, f(x) = {yi}")
print(f"Giá trị lớn nhất: {max(yvals_3d)}, nhỏ nhất: {min(yvals_3d)}\n")

#Exercise 5
import math

def golden_search(f, a, b, epsilon):
    phi = (1 + math.sqrt(5)) / 2  # Tỷ lệ vàng
    res = []

    while (b - a) >= epsilon:
        d = (b - a) * (1 - 1 / phi)
        x1 = b - d
        x2 = a + d
        f1 = f(x1)
        f2 = f(x2)
        res.append((a, b, x1, x2, f1, f2))

        if f1 < f2:
            b = x2
        else:
            a = x1

    return (a, b), res

# Hàm mục tiêu
f = lambda x: x**2

interval, steps = golden_search(f, -2, 1, 0.3)

print("Khoảng thu hẹp chứa nghiệm tối ưu:", interval)
print("\nBảng các bước lặp:")
print("a\t\tb\t\tx1\t\tx2\t\tf(x1)\t\tf(x2)")
for step in steps:
    print("\t".join(f"{x:.5f}" for x in step))

#Exercise 6
def fibonacci_search(f, a, b, epsilon):
    F = [1, 1]
    while F[-1] < (b - a) / epsilon:
        F.append(F[-1] + F[-2])

    n = len(F) - 1
    res = []

    x1 = a + (F[n - 2] / F[n]) * (b - a)
    x2 = a + (F[n - 1] / F[n]) * (b - a)
    f1 = f(x1)
    f2 = f(x2)

    for k in range(1, n):
        res.append((a, b, x1, x2, f1, f2))
        if f1 > f2:
            a = x1
            x1 = x2
            f1 = f2
            x2 = a + (F[n - k - 1] / F[n - k]) * (b - a)
            f2 = f(x2)
        else:
            b = x2
            x2 = x1
            f2 = f1
            x1 = a + (F[n - k - 2] / F[n - k]) * (b - a)
            f1 = f(x1)

    return (a, b), res

interval_fib, steps_fib = fibonacci_search(f, -2, 1, 0.3)

print("\nKhoảng thu hẹp chứa nghiệm tối ưu (Fibonacci):", interval_fib)
print("\nBảng các bước lặp (Fibonacci):")
print("a\t\tb\t\tx1\t\tx2\t\tf(x1)\t\tf(x2)")
for step in steps_fib:
    print("\t".join(f"{x:.5f}" for x in step))

#Exercise 7
import sympy as sp

x, m = sp.symbols('x m')

y = x**3 - 3*m*x**2 + 3*(m**2 - 1)*x - (m**2 - 1)

y_prime = sp.diff(y, x)

eq1 = y_prime.subs(x, 1)
m_solution = sp.solve(eq1, m)
print(f"Giá trị m để y đạt cực trị tại x = 1: {m_solution}")

y_double_prime = sp.diff(y_prime, x)
second_deriv = y_double_prime.subs({x: 1, m: m_solution[0]})
print(f"y''(1) = {second_deriv} → {'Cực đại' if second_deriv < 0 else 'Không phải cực đại'}")

#Exercise 8
def golden_search_optimize(f, a, b, epsilon):
    phi = (1 + math.sqrt(5)) / 2
    while (b - a) >= epsilon:
        d = (b - a) * (1 - 1 / phi)
        x1 = b - d
        x2 = a + d
        if f(x1) < f(x2):
            b = x2
        else:
            a = x1
    x_opt = (a + b) / 2
    return x_opt, f(x_opt)

functions_8 = [
    (lambda x: -2*x**2 + x + 4, -5, 5, 1/9),
    (lambda x: -4*x**2 + 2*x + 2, -6, 6, 1/10),
    (lambda x: x**3 + 6*x**2 + 5*x - 12, -5, -2, 1/10),
    (lambda x: 2*x - x**2, 0, 3, 1/100),
    (lambda x: x**2 - x - 10, -10, 10, 1/5),
    (lambda x: -(x + 6)**2 + 4, -10, 10, 1/8),
    (lambda x: -2*x**2 + 3*x + 6, -3, 5, 1/8),
]

for i, (f, a, b, eps) in enumerate(functions_8):
    x_opt, y_opt = golden_search_optimize(f, a, b, eps)
    print(f"--- Câu {chr(97 + i)}) ---")
    print(f"x tối ưu ≈ {x_opt:.5f}, f(x) ≈ {y_opt:.5f}\n")

