# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QcHuKiasxhZvt_wSs1yaRT8OGSl6IqPn
"""

import sympy as sp

def check_differentiability(f, x0):
    x, h = sp.symbols('x h')

    left_limit = sp.limit(f, x, x0, dir='-')
    right_limit = sp.limit(f, x, x0, dir='+')

    if left_limit != right_limit:
        print(f"Function is not continuous at x = {x0}")
        return

    left_derivative = sp.limit((f.subs(x, x0 + h) - f.subs(x, x0)) / (h), h, 0, dir='-')
    right_derivative = sp.limit((f.subs(x, x0 + h) - f.subs(x, x0)) / h, h, 0, dir='+')

    if left_derivative != right_derivative:
        print(f"Function is continuous but not differentiable at x = {x0}")
    else:
        print(f"Function is differentiable at x = {x0} with derivative {left_derivative}")

x = sp.symbols('x')
f1 = (x - 1)**(1/3)
f2 = sp.Piecewise((-x - 2, x <= -2), (x + 2, x > -2))
f3 = sp.Piecewise((x**2, x >= 0), (0, x < 0))

print("Checking f1 at x=1:")
check_differentiability(f1, 1)

print("\nChecking f2 at x=-2:")
check_differentiability(f2, -2)

print("\nChecking f3 at x=0:")
check_differentiability(f3, 0)

#11
import sympy as sp

x = sp.symbols('x')
fa = x*sp.sin(1/x)

x0 = 0
dx = sp.symbols('dx')
dfa0 = (fa.subs(x , x0 + dx) - 0) / dx
print("Derivative of f(x) at x = 0", sp.limit(dfa0, dx, 0))

import sympy as sp

x, dx = sp.symbols('x dx')

c = x**3 - 6*x**2 + 15*x

dc = (c.subs(x, x + dx) - c) / dx
dc_limit = sp.limit(dc, dx, 0)

print("Đạo hàm của c(x):", dc_limit)

cost_10 = dc_limit.subs(x, 10)
cost_11 = dc_limit.subs(x, 11)
cost_increase = cost_11 - cost_10

print("Chi phí biên khi x = 10:", cost_10)
print("Chi phí biên khi x = 11:", cost_11)
print("Tăng trưởng chi phí biên:", cost_increase)

r = 20000*(1 - (1/x))
dc = (r.subs(x, x + dx) - r) / dx
dc_limit = sp.limit(dc, dx, 0)
print("Đạo hàm của r(x):", dc_limit)

money = dc_limit.subs(x, 100)
print("Doanh thu khi 100 máy được sản xuất là", money)

t = sp.symbols('t')
b = 10**6 + 10**4*t -10**3*t**2

db = (b.subs(t, t + dx) - b) / dx
db_limit = sp.limit(db, dx, 0)
print("Đạo hàm của b(t):", db_limit)

print("Tốc độ tăng trưởng trong 0h là", db_limit.subs(t, 0))
print("Tốc độ tăng trưởng trong 5h là", db_limit.subs(t, 5))
print("Tốc độ tăng trưởng trong 10h là", db_limit.subs(t, 10))

import sympy as sp

t, dx = sp.symbols('t dx')
s = 24*t - 0.8*t**2

v = sp.simplify((s.subs(t, t + dx) - s) / dx)

a= (v.subs(t, t + dx) - v) / dx

t_max = sp.solve(v.subs(dx, 0), t)[0]
s_max = s.subs(t, t_max)

print("Vận tốc =", v.subs(dx, 0))
print("Gia tốc =", a)
print("Thời gian đạt đỉnh =", t_max)
print("Chiều cao đạt đỉnh =", s_max)

import numpy as np
import matplotlib.pyplot as plt

def newton_raphson(f, df, p0, tol=1e-8, max_iter=100):
    iterations = []
    p = p0
    for i in range(max_iter):
        f_p = f(p)
        df_p = df(p)
        if df_p == 0:
            print("Zero derivative encountered, stopping iteration.")
            break
        p_next = p - f_p / df_p
        iterations.append((i + 1, p, f_p))
        if abs(p_next - p) < tol:
            break
        p = p_next
    return iterations, p

def newton_raphson_fixed_iterations(f, df, p0, num_iter=3):
    iterations = []
    p = p0
    for i in range(num_iter):
        f_p = f(p)
        df_p = df(p)
        if df_p == 0:
            print("Zero derivative encountered, stopping iteration.")
            break
        p = p - f_p / df_p
        iterations.append((i + 1, p, f_p))
    return iterations, p

def print_table(iterations):
    print("Iteration | p | f(p)")
    print("------------------------")
    for i, p, f_p in iterations:
        print(f"{i:9} | {p:.8f} | {f_p:.8f}")

def plot_function(f, root, p0, title):
    x = np.linspace(p0 - 2, p0 + 2, 400)
    y = f(x)
    plt.plot(x, y, label="f(x)")
    plt.axhline(0, color='black', linewidth=0.5)
    plt.scatter([root], [0], color='red', label="Root")
    plt.title(title)
    plt.legend()
    plt.grid()
    plt.show()

# (a) f(x) = 2x^3 + 3x - 1
f1 = lambda x: 2*x**3 + 3*x - 1
df1 = lambda x: 6*x**2 + 3
p0_a = 2
tol_a = 1e-8
iterations_a, root_a = newton_raphson(f1, df1, p0_a, tol_a)
print("Results for f(x) = 2x^3 + 3x - 1:")
print_table(iterations_a)
plot_function(f1, root_a, p0_a, "f(x) = 2x^3 + 3x - 1")

# (b) f(x) = x^3 - 4
f2 = lambda x: x**3 - 4
df2 = lambda x: 3*x**2
p0_b = 2
iterations_b, root_b = newton_raphson_fixed_iterations(f2, df2, p0_b, 3)
print("\nResults for f(x) = x^3 - 4 (3 iterations):")
print_table(iterations_b)
plot_function(f2, root_b, p0_b, "f(x) = x^3 - 4")